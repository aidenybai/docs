{"/docs/essentials/getting-started":{"title":"Getting Started","data":{"":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<1kb 专注于编译器的虚拟 DOM - 速度非常快！\n\n当前虚拟 DOM 的实施功效并没有充分发挥出来。有些过于复杂而限制其有效地实施；有些则半途而废。如果不牺牲其初始性能和规模，其中大多数实际上是不可用的。大多要以牺牲性能和大小为代价进行调整，才变得可用。Million 就是针对这个问题的一套解决方案。它提供了一个与库无关的虚拟 DOM 作为 Javascript 库的核心，专注于预编译和静态分析。\n使用 Million，您可以获得虚拟 DOM 的声明性和灵活性，同时 利用 编译器感知优化的\n性能。\n","overview#Overview":"\nimport { m, createElement, patch } from 'million';\n\n// Initialize app\nconst app = createElement(m('div', { id: 'app' }, ['Hello World']));\ndocument.body.appendChild(app);\n// Patch content\npatch(app, m('div', { id: 'app' }, ['Goodbye World']));\n在此示例中，构造了一个虚拟节点并从中创建了一个 HTMLElement (<div id=\"app\">Hello World</div>)。 HTMLElement 附加到实时页面，然后使用虚拟节点（<div id=\"app\">Goodbye World</div>）修补（更新）。","资源--反馈#资源 & 反馈":"寻找文档？在 这里 查看。对 Million 有疑惑？把它贴在 GitHub Discussions 并向社区寻求帮助。发现一个 bug？前往 issue tracker 我们会尽力帮助你。 我们也欢迎提交 PR。我们希望所有的 Million 贡献者遵守我们的条款 Code of Conduct。→ 开始在 GitHub 上贡献代码吧"}},"/docs/essentials/installation":{"title":"Installation","data":{"":"There are 2 ways to include Million into your project:\nImporting it as a module\nIncluding it from a <script> tag\n\nMillion doesn't require build tools by default, but it is highly recommended you use NPM to install, especially if you are building a UI library.","as-a-module#As a module":"If you use NPM to install Million, ensure that you use a bundler such as Vite or Rollup.Run the following command to install it.\nnpm install million\nNow, import Million into your source file like so:\nimport {\n  m,\n  patch,\n  createElement,\n  /* or any other exports you want to access */\n} from 'million';\n","from-a-script-tag#From a script tag":"This is by far the simplest way to get started with Million. Include the following <script> tag in the head of your HTML page. Then, use a CDN like UNPKG and import million by ES Module.\n<script type=\"module\">\n  import {\n    m,\n    patch,\n    createElement,\n    /* or any other exports you want to access */\n  } from 'https://unpkg.com/million?module';\n\n  // Your code here\n</script>\nThat's it! Million is now available for use inside your page."}},"/":{"title":"Introduction","data":{"":"\n\n"}},"/docs/essentials/using-jsx":{"title":"Using JSX","data":{"":"The following declaration style:\nconst HelloWorld = <p>Hello World</p>;\nis called JSX, and it is a syntax extension to JavaScript. Much like React, you can use JSX with Million.js to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces Million VNodes. Below, you can find how to integrate JSX in your own project.","babel#Babel":"\nWe recommend using the\nbabel-preset-million preset with Babel for\nJSX transforms. Babel can easily be used with other bundlers like Webpack, Parcel, or Rollup, or\nstandalone.\nAlternatively, you can manually configure your JSX transform using @babel/plugin-transform-react-jsx.There are two main ways to transform your data, so choose the one that fits your project best.","automatic-runtime-recommended#Automatic runtime (recommended)":"Million.js provides an automatic JSX transform option through under million/jsx-runtime. Babel, by default, uses classic runtime, so you will need to explicitly state that you want automatic runtime. Additionally, you will need to specify an import source. It is not necessary to explicity import million/jsx-runtime with the automatic runtime.index.jsx\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"automatic\",\n        \"importSource\": \"million\"\n      }\n    ]\n  ]\n}\n","classic-runtime#Classic runtime":"If the automatic runtime does not work for you, or you want more fine-grained control, you should use the classic runtime. You'll need to define the pragma and pragmaFrag fields with the imports from the million/jsx-runtime, as shown below.\nThis is often more cumbersome, as you'll need to import million/jsx-runtime at every file you\nuse JSX (if you use an IDE it may appear as an unused variable).\nindex.jsx\nimport { h, Fragment } from 'million/jsx-runtime'; // This is required\n\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"classic\",\n        \"pragma\": \"h\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n","vite#Vite":"Bundlers that depend on esbuild, such as Vite, do not support or plan to implement jsx-runtime at the moment. To \"emulate\" the automatic runtime of Babel, Vite provides the jsxInject field, which automatically injects the import statement.\nEsbuild has a slightly different syntax than vite, and you should refer to the\ndocs for more information.\nindex.jsx\nconst HelloWorld = <p>Hello World</p>;\nvite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n    jsxInject: `import { h, Fragment } from 'million/jsx-runtime'`,\n  },\n});\n"}},"/docs/essentials/compiler":{"title":"Compiler","data":{"":"Million.js is intended to be the Virtual DOM runtime for your application. It's primarily designed to be augmented by a compiler which can produce optimizations and code generation for Million.js. However, Million.js doesn't provide a compiler by default, as static analysis and code generation are difficult to pull off well without knowledge of the library (state, components, etc.).However, Million.js does provide example implementations for virtual node h functions to raw objects with vite-plugin-million.If you are considering writing a compiler for your Million.js library, consider taking a look at the implemenation of vite-plugin-million. Additionally, you should look into recast and ast-types, both great options for JavaScript AST traversal for static analysis."}},"/docs/functions/toVNode":{"title":"toVNode","data":{"":"Syntax: toVNode(element)\nExample: toVNode(document.querySelector('#app'))The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m('div', { id: 'app' }, ['Hello World'], Flags.ONLY_TEXT_CHILDREN);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/functions/schedule":{"title":"schedule","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, diff, props, children, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  const diff = node([children(), props()]);\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}}}
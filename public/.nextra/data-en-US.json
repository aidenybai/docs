{"/docs/functions/toVNode":{"title":"toVNode","data":{"":"Syntax: toVNode(element)\nExample: toVNode(document.querySelector('#app'))The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m('div', { id: 'app' }, ['Hello World'], Flags.ONLY_TEXT_CHILDREN);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/functions/entity":{"title":"entity","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a vnode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst entity1 = entity(data, () => m('div', { id: 'app' }, [data.message]));\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/functions/schedule":{"title":"schedule","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, props, children, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  const diff = node([children(), props()]);\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/functions/patch":{"title":"patch","data":{"":"Syntax: patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport { m, useNode, useChildren, useProps, createElement, flush } from 'million';\n\nconst myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const diff = useNode([useChildren(), useProps()]);\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\nmyCustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an example template for your own custom driver:\nconst useDriver =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n\n    return {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n  };\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\n"}},"/":{"title":"Home","data":{"":"\n\n"}},"/blog/research":{"title":"Research","data":{"":"\n\n\n\n\n\nMillion.js\n\n","less-than-1kb-compiler-augmented-virtual-dom-its-fast#Less-than-1kb compiler-augmented virtual DOM. It's fast!":"Current Virtual DOM implementations are inadequateâ€”Ranging from overcomplicated to abandoned, most are unusable without sacrificing raw performance and size. Million aims to fix this, providing a library-agnostic Virtual DOM to serve as the core for Javascript libraries that focus on precompilation and static analysis.","project-assets#Project Assets":"\nDocumentation\nGitHub\nResearch Paper\nConference Slides\nBenchmarker\nVideo\n\n","presentation#Presentation":"\n\n"}}}
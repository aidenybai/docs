{"/":{"title":"Introduction","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\n"}},"/docs/advanced/using-jsx":{"title":"Using JSX","data":{"":"The following declaration style:\nconst HelloWorld = <p>Hello World</p>;\nis called JSX, and it is a syntax extension to JavaScript. Much like React, you can use JSX with Million.js to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces Million VNodes. Below, you can find how to integrate JSX in your own project.","babel#Babel":"\nWe recommend using the\nbabel-preset-million preset with Babel for\nJSX transforms. Babel can easily be used with other bundlers like Webpack, Parcel, or Rollup, or\nstandalone.\nAlternatively, you can manually configure your JSX transform using @babel/plugin-transform-react-jsx.There are two main ways to transform your data, so choose the one that fits your project best.","automatic-runtime-recommended#Automatic runtime (recommended)":"Million.js provides an automatic JSX transform option through under million/jsx-runtime. Babel, by default, uses classic runtime, so you will need to explicitly state that you want automatic runtime. Additionally, you will need to specify an import source. It is not necessary to explicity import million/jsx-runtime with the automatic runtime.index.jsx\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"automatic\",\n        \"importSource\": \"million\"\n      }\n    ]\n  ]\n}\n","classic-runtime#Classic runtime":"If the automatic runtime does not work for you, or you want more fine-grained control, you should use the classic runtime. You'll need to define the pragma and pragmaFrag fields with the imports from the million/jsx-runtime, as shown below.\nThis is often more cumbersome, as you'll need to import million/jsx-runtime at every file you\nuse JSX (if you use an IDE it may appear as an unused variable).\nindex.jsx\nimport { h, Fragment } from 'million/jsx-runtime'; // This is required\n\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"classic\",\n        \"pragma\": \"h\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n","vite#Vite":"Bundlers that depend on esbuild, such as Vite, do not support or plan to implement jsx-runtime at the moment. To \"emulate\" the automatic runtime of Babel, Vite provides the jsxInject field, which automatically injects the import statement.\nEsbuild has a slightly different syntax than vite, and you should refer to the\ndocs for more information.\nindex.jsx\nconst HelloWorld = <p>Hello World</p>;\nvite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n    jsxInject: `import { h, Fragment } from 'million/jsx-runtime'`,\n  },\n});\n"}},"/docs/advanced/compiler":{"title":"Compiler","data":{"":"Million.js is intended to be the Virtual DOM runtime for your application. It's primarily designed to be augmented by a compiler which can produce optimizations and code generation for Million.js. However, Million.js doesn't provide a compiler by default, as static analysis and code generation are difficult to pull off well without knowledge of the library (state, components, etc.).However, Million.js does provide example implementations for virtual node h functions to raw objects with vite-plugin-million.If you are considering writing a compiler for your Million.js library, consider taking a look at the implemenation of vite-plugin-million. Additionally, you should look into recast and ast-types, both great options for JavaScript AST traversal for static analysis."}}}
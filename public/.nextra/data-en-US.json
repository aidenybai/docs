{"/":{"title":"Introduction","data":{"":"\n\n"}},"/docs/essentials/getting-started":{"title":"Getting Started","data":{"":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<1kb compiler-augmented virtual DOM. It's fast!\n\nCurrent Virtual DOM implementations are inadequate—Ranging from overcomplicated to abandoned, most are unusable without sacrificing raw performance and size. Million aims to fix this, providing a library-agnostic Virtual DOM to serve as the core for Javascript libraries that focus on precompilation and static analysis.\nWith Million, you get the declarativity and flexibility of the Virtual DOM, while\nleveraging the\nperformance of compiler-aware optimizations.\n","overview#Overview":"\nimport { m, createElement, patch } from 'million';\n\n// Initialize app\nconst app = createElement(m('div', { id: 'app' }, ['Hello World']));\ndocument.body.appendChild(app);\n// Patch content\npatch(app, m('div', { id: 'app' }, ['Goodbye World']));\nIn this example, a virtual node is constructed and a HTMLElement (<div id=\"app\">Hello World</div>) is created out of it. The HTMLElement is attached to the live page, and then patched (updated) using a virtual node (<div id=\"app\">Goodbye World</div>).","resources--contributing-back#Resources & Contributing Back":"Have a question about Million? Post it on the GitHub Discussions and ask the community for help.Find a bug? Head over to our issue tracker and we'll do our best to help. We love pull requests, too!We expect all Million contributors to abide by the terms of our Code of Conduct.→ Start contributing on GitHub"}},"/docs/essentials/compiler":{"title":"Compiler","data":{"":"Million.js is intended to be the Virtual DOM runtime for your application. It's primarily designed to be augmented by a compiler which can produce optimizations and code generation for Million.js. However, Million.js doesn't provide a compiler by default, as static analysis and code generation are difficult to pull off well without knowledge of the library (state, components, etc.).However, Million.js does provide example implementations for virtual node h functions to raw objects with vite-plugin-million.If you are considering writing a compiler for your Million.js library, consider taking a look at the implemenation of vite-plugin-million. Additionally, you should look into recast and ast-types, both great options for JavaScript AST traversal for static analysis."}},"/docs/essentials/using-jsx":{"title":"Using JSX","data":{"":"The following declaration style:\nconst HelloWorld = <p>Hello World</p>;\nis called JSX, and it is a syntax extension to JavaScript. Much like React, you can use JSX with Million.js to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces Million VNodes. Below, you can find how to integrate JSX in your own project.","babel#Babel":"\nWe recommend using the\nbabel-preset-million preset with Babel for\nJSX transforms. Babel can easily be used with other bundlers like Webpack, Parcel, or Rollup, or\nstandalone.\nAlternatively, you can manually configure your JSX transform using @babel/plugin-transform-react-jsx.There are two main ways to transform your data, so choose the one that fits your project best.","automatic-runtime-recommended#Automatic runtime (recommended)":"Million.js provides an automatic JSX transform option through under million/jsx-runtime. Babel, by default, uses classic runtime, so you will need to explicitly state that you want automatic runtime. Additionally, you will need to specify an import source. It is not necessary to explicity import million/jsx-runtime with the automatic runtime.index.jsx\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"automatic\",\n        \"importSource\": \"million\"\n      }\n    ]\n  ]\n}\n","classic-runtime#Classic runtime":"If the automatic runtime does not work for you, or you want more fine-grained control, you should use the classic runtime. You'll need to define the pragma and pragmaFrag fields with the imports from the million/jsx-runtime, as shown below.\nThis is often more cumbersome, as you'll need to import million/jsx-runtime at every file you\nuse JSX (if you use an IDE it may appear as an unused variable).\nindex.jsx\nimport { h, Fragment } from 'million/jsx-runtime'; // This is required\n\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"classic\",\n        \"pragma\": \"h\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n","vite#Vite":"Bundlers that depend on esbuild, such as Vite, do not support or plan to implement jsx-runtime at the moment. To \"emulate\" the automatic runtime of Babel, Vite provides the jsxInject field, which automatically injects the import statement.\nEsbuild has a slightly different syntax than vite, and you should refer to the\ndocs for more information.\nindex.jsx\nconst HelloWorld = <p>Hello World</p>;\nvite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n    jsxInject: `import { h, Fragment } from 'million/jsx-runtime'`,\n  },\n});\n"}},"/docs/essentials/installation":{"title":"Installation","data":{"":"There are 2 ways to include Million into your project:\nImporting it as a module\nIncluding it from a <script> tag\n\nMillion doesn't require build tools by default, but it is highly recommended you use NPM to install, especially if you are building a UI library.","as-a-module#As a module":"If you use NPM to install Million, ensure that you use a bundler such as Vite or Rollup.Run the following command to install it.\nnpm install million\nNow, import Million into your source file like so:\nimport {\n  m,\n  patch,\n  createElement,\n  /* or any other exports you want to access */\n} from 'million';\n","from-a-script-tag#From a script tag":"This is by far the simplest way to get started with Million. Include the following <script> tag in the head of your HTML page. Then, use a CDN like UNPKG and import million by ES Module.\n<script type=\"module\">\n  import {\n    m,\n    patch,\n    createElement,\n    /* or any other exports you want to access */\n  } from 'https://unpkg.com/million?module';\n\n  // Your code here\n</script>\nThat's it! Million is now available for use inside your page."}},"/docs/functions/toVNode":{"title":"toVNode","data":{"":"Syntax: toVNode(element)\nExample: toVNode(document.querySelector('#app'))The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m('div', { id: 'app' }, ['Hello World'], Flags.ONLY_TEXT_CHILDREN);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/functions/m":{"title":"m","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\n","classname-and-style-props#className and style props":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#Kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","flags#Flags":"Flags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated vnode is provided as the previous vnode during a patch\ncall.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a vnode.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please hard replace me'], Flags.REPLACE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Hello ', 'World!'], Flags.ONLY_TEXT_CHILDREN);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n","deltas#Deltas":"Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the vnode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [Delta.INSERT(0), Delta.UPDATE(0)]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/functions/createElement":{"title":"createElement","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World'], Flags.ONLY_TEXT_CHILDREN);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/functions/patch":{"title":"patch","data":{"":"Syntax: patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport { m, useNode, useChildren, useProps, createElement, flush } from 'million';\n\nconst myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const diff = useNode([useChildren(), useProps()]);\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\nmyCustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an example template for your own custom driver:\nconst useDriver =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n\n    return {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n  };\n"}},"/docs/functions/schedule":{"title":"schedule","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, props, children, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  const diff = node([children(), props()]);\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}}}
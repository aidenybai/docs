{"/":{"title":"Home","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\n"}},"/docs/advanced/using-jsx":{"title":"Using JSX","data":{"":"The following declaration style:\nconst HelloWorld = <p>Hello World</p>;\nis called JSX, and it is a syntax extension to JavaScript. Much like React, you can use JSX with Million.js to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces Million VNodes. Below, you can find how to integrate JSX in your own project.","babel#Babel":"\nWe recommend using the\nbabel-preset-million preset with Babel for\nJSX transforms. Babel can easily be used with other bundlers like Webpack, Parcel, or Rollup, or\nstandalone.\nAlternatively, you can manually configure your JSX transform using @babel/plugin-transform-react-jsx.There are two main ways to transform your data, so choose the one that fits your project best.","automatic-runtime-recommended#Automatic runtime (recommended)":"Million.js provides an automatic JSX transform option through under million/jsx-runtime. Babel, by default, uses classic runtime, so you will need to explicitly state that you want automatic runtime. Additionally, you will need to specify an import source. It is not necessary to explicity import million/jsx-runtime with the automatic runtime.index.jsx\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"automatic\",\n        \"importSource\": \"million\"\n      }\n    ]\n  ]\n}\n","classic-runtime#Classic runtime":"If the automatic runtime does not work for you, or you want more fine-grained control, you should use the classic runtime. You'll need to define the pragma and pragmaFrag fields with the imports from the million/jsx-runtime, as shown below.\nThis is often more cumbersome, as you'll need to import million/jsx-runtime at every file you\nuse JSX (if you use an IDE it may appear as an unused variable).\nindex.jsx\nimport { h, Fragment } from 'million/jsx-runtime'; // This is required\n\nconst HelloWorld = <p>Hello World</p>;\n.babelrc\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"runtime\": \"classic\",\n        \"pragma\": \"h\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n","vite#Vite":"Bundlers that depend on esbuild, such as Vite, do not support or plan to implement jsx-runtime at the moment. To \"emulate\" the automatic runtime of Babel, Vite provides the jsxInject field, which automatically injects the import statement.\nEsbuild has a slightly different syntax than vite, and you should refer to the\ndocs for more information.\nindex.jsx\nconst HelloWorld = <p>Hello World</p>;\nvite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n    jsxInject: `import { h, Fragment } from 'million/jsx-runtime'`,\n  },\n});\n"}},"/docs/functions/entity":{"title":"entity","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a vnode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst entity1 = entity(data, () => m('div', { id: 'app' }, [data.message]));\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/functions/schedule":{"title":"schedule","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, props, children, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  const diff = node([children(), props()]);\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/functions/createElement":{"title":"createElement","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World'], Flags.ONLY_TEXT_CHILDREN);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}}}
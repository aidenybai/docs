{"/":{"title":"Home","data":{"":"\n\n"}},"/blog/research":{"title":"Research","data":{"":"\n\n\n\n\n\nMillion.js\n\n","less-than-1kb-compiler-augmented-virtual-dom-its-fast#Less-than-1kb compiler-augmented virtual DOM. It's fast!":"Current Virtual DOM implementations are inadequateâ€”Ranging from overcomplicated to abandoned, most are unusable without sacrificing raw performance and size. Million aims to fix this, providing a library-agnostic Virtual DOM to serve as the core for Javascript libraries that focus on precompilation and static analysis.","project-assets#Project Assets":"\nDocumentation\nGitHub\nResearch Paper\nConference Slides\nBenchmarker\nVideo\n\n","presentation#Presentation":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\n"}},"/docs/functions/m":{"title":"m","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\n","classname-and-style-props#className and style props":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#Kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","flags#Flags":"Flags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated vnode is provided as the previous vnode during a patch\ncall.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a vnode.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please hard replace me'], Flags.REPLACE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Hello ', 'World!'], Flags.ONLY_TEXT_CHILDREN);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n","deltas#Deltas":"Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the vnode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [Delta.INSERT(0), Delta.UPDATE(0)]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/functions/createElement":{"title":"createElement","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World'], Flags.ONLY_TEXT_CHILDREN);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}}}
{"/":{"title":"Home","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\npatch() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the live DOM reference, and the second one is a Virtual DOM to render.createElement() function converts a \"Virtual DOM\" node into a real DOM node.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/functions/m":{"title":"VNode","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\n","classname-and-style-props#className and style props":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#Kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","flags#Flags":"Flags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated vnode is provided as the previous vnode\nduring a patch call.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a vnode.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Please hard replace me'],\n  Flags.REPLACE_NODE,\n);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Hello ', 'World!'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n","deltas#Deltas":"Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the vnode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [\n  Delta.INSERT(0),\n  Delta.UPDATE(0),\n]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/functions/createElement":{"title":"createElement()","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/functions/schedule":{"title":"schedule()","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, diff, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/functions/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport {\n  m,\n  useNode,\n  useChildren,\n  useProps,\n  createElement,\n  flush,\n} from 'million';\n\nconst myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const diff = useNode([useChildren(), useProps()]);\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\nmyCustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an example template for your own custom driver:\nconst useDriver =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n\n    return {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n  };\n"}},"/docs/functions/entity":{"title":"entity()","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a vnode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst customEntity = entity(data, () =>\n  m('div', { id: 'app' }, [data.message]),\n);\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/functions/toVNode":{"title":"toVNode()","data":{"":"Syntax: toVNode(element)\nExample: toVNode(document.querySelector('#app'))The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/functions/vnode/m":{"title":"m()","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\n","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","classname-and-style-props-helpers#className and style props helpers":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","tovnode-ssr-helper#toVNode SSR helper":"The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/functions/vnode/entity":{"title":"entity()","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a vnode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst customEntity = entity(data, () =>\n  m('div', { id: 'app' }, [data.message]),\n);\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/functions/vnode/toVNode":{"title":"toVNode()","data":{"":"Syntax: toVNode(element)\nExample: toVNode(document.querySelector('#app'))The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/functions/render/createElement":{"title":"createElement()","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/functions/render/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport {\n  m,\n  useNode,\n  useChildren,\n  useProps,\n  createElement,\n  flush,\n} from 'million';\n\nconst myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const diff = useNode([useChildren(), useProps()]);\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\nmyCustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an example template for your own custom driver:\nconst useDriver =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n\n    return {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n  };\n"}},"/docs/functions/render/schedule":{"title":"schedule()","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, diff, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/functions/vnode/flags":{"title":"flags","data":{"":"Syntax: Flags.FLAG_NAME\nExample: Flags.IGNORE_NODEFlags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated vnode is provided as the previous vnode\nduring a patch call.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a vnode.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Please hard replace me'],\n  Flags.REPLACE_NODE,\n);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Hello ', 'World!'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n"}},"/docs/functions/vnode/delta":{"title":"delta","data":{"":"Syntax: Delta.OPERATION(index)\nExample: Delta.INSERT(0)Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the vnode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [\n  Delta.INSERT(0),\n  Delta.UPDATE(0),\n]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/api/vnode/m":{"title":"m()","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\n","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","classname-and-style-props-helpers#className and style props helpers":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","tovnode-ssr-helper#toVNode SSR helper":"The toVNode function converts an HTMLElement or Text to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\nconst el = document.querySelector('#app');\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst oldVNode = toVNode(el);\n\npatch(el, vnode, oldVNode);\n\n<div id=\"app\">Hello World</div>\n"}},"/docs/api/vnode/entity":{"title":"entity()","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a vnode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst customEntity = entity(data, () =>\n  m('div', { id: 'app' }, [data.message]),\n);\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/api/render/createElement":{"title":"createElement()","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/api/render/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport {\n  m,\n  useNode,\n  useChildren,\n  useProps,\n  createElement,\n  flush,\n} from 'million';\n\nconst myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const diff = useNode([useChildren(), useProps()]);\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\nmyCustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an example template for your own custom driver:\nconst useDriver =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n\n    return {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n  };\n"}},"/docs/api/vnode/delta":{"title":"Delta","data":{"":"Syntax: Delta.OPERATION(index)\nExample: Delta.INSERT(0)Deltas are a way for the compile-time to optimize runtime operations by providing a set of predefined operations. This is useful for cases where you are performing consistent, predictable operations at a high interval, low payload situation.There are three types of delta operations: Delta.INSERT, Delta.UPDATE, and Delta.DELETE. You can provide a specified index to select the position of the vnode's children to be inserted, updated, or deleted.\nDelta.INSERT is used to add children at a selected index.\nSyntax: Delta.INSERT(index)\nExample: IDelta.NSERT(0)\nDelta.UPDATE is used to replace children at a selected index.\nSyntax: Delta.UPDATE(index)\nExample: Delta.UPDATE(0)\nDelta.DELETE is used to remove children at a selected index.\nSyntax: Delta.DELETE(index)\nExample: Delta.DELETE(0)\n\nYou can load these operations into a delta, or an array. You can pass them inside the m function.\nimport { m, Delta } from 'million';\n\nconst vnode = m('div', undefined, ['Hello World'], undefined, [\n  Delta.INSERT(0),\n  Delta.UPDATE(0),\n]);\n\n{\n  tag: 'div',\n  children: ['Hello World'],\n  delta: [\n    [0 /* DeltaTypes.INSERT */, 0],\n    [1 /* DeltaTypes.UPDATE */, 0],\n  ]\n}\n"}},"/docs/api/vnode/flags":{"title":"Flags","data":{"":"Syntax: Flags.FLAG_NAME\nExample: Flags.IGNORE_NODEFlags allow for the patch function to optimize condition branches. They are optional, but are highly recommended, as they make time complexity much more efficient and can be precomputed during compile-time.\nFlags will be ignored if the generated vnode is provided as the previous vnode\nduring a patch call.\n\nFlags.IGNORE_NODE\nThis flag should be used when you know for sure that you don't need to perform any patching on a node. This is useful for optimizing static regions within interactive regions.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);\n\n{\n  tag: 'div',\n  children: ['Please ignore me'],\n  flag: /* Flags.IGNORE_NODE */,\n}\n\nFlags.REPLACE_NODE\nIf you need to add group functionality, using this flag allows you to skip diffing entirely and hard replace a vnode.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Please hard replace me'],\n  Flags.REPLACE_NODE,\n);\n\n{\n  tag: 'div',\n  children: ['Please hard replace me'],\n  flag: /* Flags.REPLACE_NODE */,\n}\n\nFlags.NO_CHILDREN\nIf your element has no children, you can set this flag to skip the children diffing entirely.\nimport { m, Flags } from 'million';\n\nconst vnode = m('div', undefined, [], Flags.NO_CHILDREN);\n\n{\n  tag: 'div',\n  children: [],\n  flag: /* Flags.NO_CHILDREN */,\n}\n\nFlags.ONLY_TEXT_CHILDREN\nIf your element has only text children, you can set this flag to skip the children diffing and only mutate the textContent property of the HTMLElement.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Hello ', 'World!'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Hello ', 'World!'],\n  flag: /* Flags.ONLY_TEXT_CHILDREN */,\n}\n\nFlags.ONLY_KEYED_CHILDREN\nIf your element has only VElement children with keys, you can set this flag to default to enable special diffing. This allows for more performant runtime diffing, since it can leverage the key map to do comparisons for more pinpoint modifications.For example, without keyed diffing, each node is linearly diffed, resulting sometimes in unnecessary modifications. As seen below, we insert an X child at the start of the newVNodeChildren, but all nodes are modified because the first 3 are diffed and updated, and the last is appended. This could be much more efficient if only the X was inserted at the start.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nHowever, with keyed diffing, we can see more performant results. As you can see, only the X is modified and inserted at the start, with the other nodes being ignored during diffing.\noldVNodeChildren:\n  A,\n  B,\n  C,\n\nnewVNodeChildren:\n  X,\n  A,\n  B,\n  C,\nSo, how do you enable this? Generally, you should if you have unique content in your values. Never supply the index of the item in the array or non-unique keys into the VNode.\nimport { m, Flags } from 'million';\n\nconst list = ['foo', 'bar', 'baz'];\n\nconst vnode = m(\n  'div',\n  undefined,\n  list.map((item) => m('p', { key: item }, [item])),\n  Flags.ONLY_KEYED_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: [\n    m('p', { key: 'foo' }, ['foo']),\n    m('p', { key: 'bar' }, ['bar']),\n    m('p', { key: 'foo' }, ['baz']),\n  ],\n  flag: /* Flags.ONLY_KEYED_CHILDREN */,\n}\n\nFlags.ANY_CHILDREN\nIf your element has a mix or only VElement children, you can set this flag to default to normal diffing. Generally, you don't need to explicity set this flag, as it is the default behavior.\nimport { m, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  undefined,\n  ['Here is my button: ', m('button', undefined, ['Hi!'])],\n  Flags.ANY_CHILDREN,\n);\n\n{\n  tag: 'div',\n  children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],\n  flag: /* Flags.ANY_CHILDREN */,\n}\n\n\n"}},"/docs/api/render/schedule":{"title":"schedule()","data":{"":"Syntax: schedule(callback)\nExample: schedule(() => patch(el, m('div')))The schedule function is used as a deferred commit function to prevent main thread blocking.Scheduling is generally used to induce incremental rendering, or the ability to split rendering work into chunks and spread it out over multiple frames. Generally, you want to use it if you are repeating a certain patches many times, or you want to debounce an operation.\nimport { m, diff, schedule, createElement } from 'million';\n\nconst patch = (el, newVNode, oldVNode, effects = []): DOMNode => {\n  // async rendering\n  const data = diff(el, newVNode, oldVNode, effects, schedule);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\n// async rendering\nschedule(() => {\n  patch(el, vnode1);\n});\n"}},"/docs/api/crash-course":{"title":"crash-course","data":{"":""}},"/docs/api/getting-started":{"title":"getting-started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\npatch() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the live DOM reference, and the second one is a Virtual DOM to render.createElement() function converts a \"Virtual DOM\" node into a real DOM node.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/crash-course":{"title":"Crash Course","data":{"":"\nThis page is still in construction. For now, please refer to the API\nreference.\n"}},"/blog/research":{"title":"Research","data":{"":"","less-than-1kb-compiler-augmented-virtual-dom-its-fast#Less-than-1kb compiler-augmented virtual DOM. It's fast!":"Current Virtual DOM implementations are inadequate—Ranging from overcomplicated to abandoned, most are unusable without sacrificing raw performance and size. Million aims to fix this, providing a library-agnostic Virtual DOM to serve as the core for Javascript libraries that focus on precompilation and static analysis.","project-assets#Project Assets":"\nDocumentation\nGitHub\nResearch Paper\nConference Slides\nBenchmarker\nVideo\n\n","presentation#Presentation":"\n\n"}},"/blog/virtual-dom":{"title":"Virtual DOM","data":{"":"","introduction#Introduction":"The virtual DOM is a tree of virtual nodes that represents what the DOM looks like. Virtual nodes are light, stateless, and are strings or JavaScript objects that only contain necessary fields. Virtual nodes can be assembled into trees, and \"diffed\" to make pinpoint changes to the DOM.The reasoning behind this is because modification and access of DOM nodes is computationally expensive. A diff between virtual nodes, accessing the DOM only for modification, is the premise of virtual DOM. It avoids the DOM as much as possible, favoring plain JavaScript objects instead, making reading and writing much cheaper.","how-does-it-work#How does it work?":"The Million virtual DOM contains three main functions: m, createElement, patch. To completely understand how virtual DOM works, let's try and create our own rudimentary virtual DOM based off of these functions (~7 minutes read time).Before we start, we need to define what a virtual node is. A virtual node can either be a JavaScript object (virtual element) or a string (text).The m function is a helper function that creates virtual elements. A virtual element contains three properties:\ntag: which stores the tag name of the element as a string.\nprops: which stores the properties/attributes of the element as an object.\nchildren: which stores virtual node children of the element as an array.\n\nAn example implementation of the m helper function is below:\nconst m = (tag, props = {}, children = []) => ({\n  tag,\n  props,\n  children,\n});\nThis way, we can construct virtual elements easily:\nm('div', { id: 'app' }, ['Hello World']);\n// Is the same as:\n{\n  tag: 'div',\n  props: { id: 'app' },\n  children: ['Hello World']\n}\nThe createElement function turns a virtual node into a real DOM element. This is important because we'll be using this in our patch function and the user may also use it to initialize their application.We'll need to programmatically create a new detached DOM element, then iterate over the virtual element props while adding them to the DOM element, and finally iterating over the children, initializing them as well. An example implementation of the createElement helper function is below:\nconst createElement = (vnode) => {\n  if (typeof vnode === 'string') return document.createTextNode(vnode);\n\n  const el = document.createElement(vnode.tag);\n\n  for (const propName in vnode.props) {\n    el[propName] = vnode.props[propName];\n  }\n\n  for (const child of vnode.children) {\n    el.appendChild(createElement(child));\n  }\n\n  return el;\n};\nThis way, we can convert virtual nodes to DOM elements easily:\ncreateElement(m('div', { id: 'app' }, ['Hello World']));\n// Is the same as: <div id=\"app\">Hello World</div>\nThe patch function takes an existing DOM element, old virtual node, and new virtual node. This won't necessarily be the most performant implementation, but this is just for demonstration purposes.We'll need to diff the two virtual nodes, then replace out the element when needed. We do this by first determining whether one of the virtual nodes is a text, or a string, and replacing it if the old and new virtual nodes do not equate each other. Otherwise, we can safely assume both are virtual elements. After that, we diff the tag and props, and replace the element if the tag has changed. We then iterate over the children and recursively patch if a child is a virtual element. An example implementation of the patch helper function is below:\nconst patch = (el, newVNode, oldVNode) => {\n  if (!newVNode && newVNode !== '') return el.remove();\n  if (typeof oldVNode === 'string' || typeof newVNode === 'string') {\n    if (oldVNode !== newVNode) return el.replaceWith(createElement(newVNode));\n  } else {\n    if (oldVNode?.tag !== newVNode.tag) {\n      return el.replaceWith(createElement(newVNode));\n    }\n\n    if (oldVNode) {\n      for (const propName in oldVNode.props) {\n        if (oldVNode.props[propName] === newVNode.props[propName])\n          return el.replaceWith(createElement(newVNode));\n      }\n\n      for (let i = el.childNodes.length - 1; i >= 0; i--) {\n        patch(el.childNodes[i], newVNode.children[i], oldVNode.children[i]);\n      }\n    }\n  }\n};\nThis way, we can patch DOM elements based on virtual nodes easily:\nconst oldVNode = m('div', { id: 'app' }, ['Hello World']);\nconst newVNode = m('div', { id: 'app' }, ['Goodbye World']);\nconst el = createElement(oldVNode);\n// <div id=\"app\">Hello World</div>\n\npatch(el, oldVNode, newVNode);\n// el will become: <div id=\"app\">Goodbye World</div>\nNotes:\nThe old virtual node must always model the DOM element until after it is patched.\nGenerally speaking, applications aren't directly written with these methods, rather they should be abstracted out into components and JSX for simplicity.\nThis is not the same as Million's implementation, rather it is a demonstration to better allow you to understand how the virtual DOM works.\n\n","so-whats-unique-about-million-then#So... What's unique about Million then?":"Million provides many major improvements: granular patching, fewer iterative passes, fast text interpolation, keyed virtual nodes, compiler flags, deltas, batching, and scheduling.\nGranular patching: Instead of just replacing the entire element when there is a difference in props or children, only the necessary props are changed.\nFewer iterative passes: Million attempts to reduce the amount of passes during diffing, allowing for better time and space complexity.\nFast text interpolation: Instead of replacing text nodes with DOM methods, Million uses compiler flags to set the textContent of elements to boost performance.\nKeyed virtual elements: This allows for the patching algorithm to skip nodes if the new virtual element key is the same as the old one, minimizing the amount of unnecessary work.\nCompiler Flags: This allows for the patching algorithm to skip condition branches, meaning less work is done.\nDeltas: Microactions can be preprogrammed to skip diffing children all together, resulting in a better time complexity and while being easily leveraged by a compiler.\nBatching & Scheduling: Batching together DOM manipulations is baked in by default, and task scheduling is composable for your own uses.\n\n"}}}
{"/":{"title":"Home","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\npatch() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the live DOM reference, and the second one is a Virtual DOM to render.createElement() function converts a \"Virtual DOM\" node into a real DOM node.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/vnode/entity":{"title":"entity()","data":{"":"Syntax: entity(data, resolve, el?)\nExample: entity({}, () => m('div'))It is recommended that you use entity to create a Entity. It accepts data as a object, a resolver that returns a VNode, and an optional element reference.You can use entity to create components. For instance, a reference to the component function and props can be passed into data. Additionally, you can resolve the component in the resolver function.\nimport { m } from 'million';\n\nconst data = { message: 'Hello World' };\nconst customEntity = entity(data, () =>\n  m('div', { id: 'app' }, [data.message]),\n);\n\n{\n  data: { message: 'Hello World' },\n  resolve: () => ({\n    tag: 'div',\n    props: {\n      id: 'app'\n    },\n    children: ['Hello World'],\n  }),\n  el: undefined\n}\n"}},"/docs/api/vnode/m":{"title":"m()","data":{"":"Syntax: m(tag, props?, children?, flag?, delta?)\nExample: m('div', { id: 'app' }, ['Hello World'])It is recommended that you use m to create a VNode. It accepts a tag as a string, an optional props object, an optional array of children, and an optional flag.\nimport { m } from 'million';\n\nconst vnode = m('div', { id: 'app' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  children: ['Hello World'],\n}\nThe tagName is stored under the tag, attributes and properties are stored under props, and the children are stored under children.","optimization-via-keys#Optimization via keys":"Most of the time, the diffing and patching process is fast enough, but when dealing with a large amount of children, it is best to provide runtime hints through keys. You can attach a key under props. When patched, it will only diff props and children if the key is changed. For more advanced runtime diffing using keys, check out Flags.ONLY_KEYED_CHILDREN.\nimport { m } from 'million';\n\nconst vnode = m('div', { key: 'foo' }, ['Hello World']);\n\n{\n  tag: 'div',\n  props: {},\n  children: ['Hello World'],\n  key: 'foo',\n}\n","classname-and-style-props-helpers#className and style props helpers":"The className and style props need to be preprocessed using the className and style functions to convert objects to strings. The class object syntax allows for you to toggle classes based on a boolean value. The style object syntax allows you to set styles in a clean format.\nimport { m, className, style } from 'million';\n\nconst vnode = m(\n  'div',\n  {\n    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),\n    style: style({ color: 'black', 'font-weight': 'bold' }),\n  },\n  ['Hello World'],\n);\n\n{\n  tag: 'div',\n  props: {\n    className: 'class1 class3',\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","kebab-props-helper#kebab props helper":"Generally, the values of className and style props are objects in kebab-case. However, if you want to use camelCase for the keys of these props, you can use the kebab function to convert the keys from camelCase to kebab-case.\nimport { m, style, kebab } from 'million';\n\nconst vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));\n\n{\n  tag: 'div',\n  props: {\n    style: 'color:black;font-weight:bold'\n  },\n  children: ['Hello World'],\n}\n","svg-support#SVG support":"SVGs are handled by default, but sometimes you need to attach SVG namespaces. SVGs are processed using the svg function to add ns props to the element and all of the children of that element.\nimport { m, svg } from 'million';\n\nconst vnode = svg(m('svg'));\n\n{\n  tag: 'svg',\n  props: {\n    ns: 'http://www.w3.org/2000/svg'\n  },\n}\n","tovnode-ssr-helper#toVNode SSR helper":"The toVNode function converts an HTMLElement or Text or HTML string to a VNode. This is generally used to rehydrate HTML from SSR.\nimport { m, toVNode, patch } from 'million';\n\n// HTML string\nconst vnode1 = toVNode('<div>Hello World</div>'); // holds <div>Hello World</div> in VNode form\n\n// HTMLElement\nconst el = document.createElement('div');\nel.textContent = 'Hello World';\nconst vnode2 = toVNode(el); // holds <div>Hello World</div> in VNode form\n\n<div id=\"app\">Hello World</div>\n"}},"/blog/research":{"title":"Research","data":{"":"","less-than-1kb-compiler-augmented-virtual-dom-its-fast#Less-than-1kb compiler-augmented virtual DOM. It's fast!":"Current Virtual DOM implementations are inadequate—Ranging from overcomplicated to abandoned, most are unusable without sacrificing raw performance and size. Million aims to fix this, providing a library-agnostic Virtual DOM to serve as the core for Javascript libraries that focus on precompilation and static analysis.","project-assets#Project Assets":"\nDocumentation\nGitHub\nResearch Paper\nConference Slides\nBenchmarker\nVideo\n\n","presentation#Presentation":"\n\n"}},"/blog/manifesto":{"title":"Manifesto","data":{"":"","past#Past":"Back in the days when JavaScript was first manifested, direct DOM manipulation was used to introduce interactivity for static web sites. Eventually, the JavaScript scene moved on to new technologies such as MooTools and jQuery, which helped simplify certain actions into simple, reusable functions. However, there was still one pressing issue.Even though web development became easier, scaling large web applications that required an extensive amount of interactivity was difficult, as operations were generally imperative and difficult to organize. This led the rise to several frameworks and libraries, notably React. React aimed to allow for declarative development and componentization to compose user interfaces scalably. To achieve this, the team behind React used a Virtual DOM architecture, where computation and logic was deferred to an algorithm to determine changes. This means that the developer just has to figure out how the markup will look.React helped to pioneer extensive usage of JavaScript to render web applications, leading to the rise of the Virtual DOM architecture in other libraries and usage of new technologies like JSX.","present#Present":"Nowadays, the prevalence of web applications is non-negligible. JavaScript and React are everywhere, and the Virtual DOM architecture is used in many of the popular libraries today (React.js, Vue.js, Preact.js, Elm, etc). \"Pure JavaScript rendering\" has subsided as development of preprocessors such as Webpack have taken hold as a standard, leading the way to preprocessors, allowing for cross-browser compatibility (e.g. Babel), prerendering, and JAMstack technologies.JavaScript frameworks and libraries have entire ecosystems around them, with tools like Next.js around React supercharging how web development is done. Library developers are slowly realizing the importance of performance sacrificed in the previous generation of developers for the purpose of developer experience. This is seen with trends towards static analysis with Svelte, which currently leverages the prevalent usage of bundlers in most web applications.Performance is slowly becoming a priority, but technologies that depend on the Virtual DOM like React are fundamentally outdated, even with incremental improvements with lazy loading and ISR in Next.js.","future#Future":"It is easy to to recite, reinvent, and monkey-patch what exists. With React and the Virtual DOM being such a backbone technology in the JavaScript library space, it is paramount that bleeding-edge libraries like Next.js leverage their position in the ecosystem to pioneer compiler-based optimizations. While the most straightforward solution is to ditch everything and use the browser just as compile target with a series of imperative operations, the Virtual DOM arguably brings many advantages. It helps us write declarative interfaces without templating, meaning conditions are constrained to the limit of JavaScript, as well as many other benefits.The future of the Virtual DOM is not destruction of the Virtual DOM, rather it is to constrain usage of the Virtual DOM where it is powerful while leveraging static analysis and compilation (This is done through Million.js).→ Interested in how Million is different?\nI recently had the opportunity to chat with @rauchg about Million.js as well as some of my thoughts on the current state of Virtual DOM. He explained to me that optimization of the Virtual DOM was only a facet of the next phase of web frameworks. This includes how we can improve development mode experience, tree-shaking and bundle size, etc.\naggressive tree shaking - reduce bundle size. I highly recommend you to check out his Twitter and blog, as he has so much valuable insight into the industry and how impact can and needs to be made.\n"}},"/blog/virtual-dom":{"title":"Virtual DOM","data":{"":"","introduction#Introduction":"The virtual DOM is a tree of virtual nodes that represents what the DOM looks like. Virtual nodes are light, stateless, and are strings or JavaScript objects that only contain necessary fields. Virtual nodes can be assembled into trees, and \"diffed\" to make pinpoint changes to the DOM.The reasoning behind this is because modification and access of DOM nodes is computationally expensive. A diff between virtual nodes, accessing the DOM only for modification, is the premise of virtual DOM. It avoids the DOM as much as possible, favoring plain JavaScript objects instead, making reading and writing much cheaper.","how-does-it-work#How does it work?":"The Million virtual DOM contains three main functions: m, createElement, patch. To completely understand how virtual DOM works, let's try and create our own rudimentary virtual DOM based off of these functions (~7 minutes read time).Before we start, we need to define what a virtual node is. A virtual node can either be a JavaScript object (virtual element) or a string (text).The m function is a helper function that creates virtual elements. A virtual element contains three properties:\ntag: which stores the tag name of the element as a string.\nprops: which stores the properties/attributes of the element as an object.\nchildren: which stores virtual node children of the element as an array.\n\nAn example implementation of the m helper function is below:\nconst m = (tag, props = {}, children = []) => ({\n  tag,\n  props,\n  children,\n});\nThis way, we can construct virtual elements easily:\nm('div', { id: 'app' }, ['Hello World']);\n// Is the same as:\n{\n  tag: 'div',\n  props: { id: 'app' },\n  children: ['Hello World']\n}\nThe createElement function turns a virtual node into a real DOM element. This is important because we'll be using this in our patch function and the user may also use it to initialize their application.We'll need to programmatically create a new detached DOM element, then iterate over the virtual element props while adding them to the DOM element, and finally iterating over the children, initializing them as well. An example implementation of the createElement helper function is below:\nconst createElement = (vnode) => {\n  if (typeof vnode === 'string') return document.createTextNode(vnode);\n\n  const el = document.createElement(vnode.tag);\n\n  for (const propName in vnode.props) {\n    el[propName] = vnode.props[propName];\n  }\n\n  for (const child of vnode.children) {\n    el.appendChild(createElement(child));\n  }\n\n  return el;\n};\nThis way, we can convert virtual nodes to DOM elements easily:\ncreateElement(m('div', { id: 'app' }, ['Hello World']));\n// Is the same as: <div id=\"app\">Hello World</div>\nThe patch function takes an existing DOM element, old virtual node, and new virtual node. This won't necessarily be the most performant implementation, but this is just for demonstration purposes.We'll need to diff the two virtual nodes, then replace out the element when needed. We do this by first determining whether one of the virtual nodes is a text, or a string, and replacing it if the old and new virtual nodes do not equate each other. Otherwise, we can safely assume both are virtual elements. After that, we diff the tag and props, and replace the element if the tag has changed. We then iterate over the children and recursively patch if a child is a virtual element. An example implementation of the patch helper function is below:\nconst patch = (el, newVNode, oldVNode) => {\n  if (!newVNode && newVNode !== '') return el.remove();\n  if (typeof oldVNode === 'string' || typeof newVNode === 'string') {\n    if (oldVNode !== newVNode) return el.replaceWith(createElement(newVNode));\n  } else {\n    if (oldVNode?.tag !== newVNode.tag) {\n      return el.replaceWith(createElement(newVNode));\n    }\n\n    if (oldVNode) {\n      for (const propName in oldVNode.props) {\n        if (oldVNode.props[propName] === newVNode.props[propName])\n          return el.replaceWith(createElement(newVNode));\n      }\n\n      for (let i = el.childNodes.length - 1; i >= 0; i--) {\n        patch(el.childNodes[i], newVNode.children[i], oldVNode.children[i]);\n      }\n    }\n  }\n};\nThis way, we can patch DOM elements based on virtual nodes easily:\nconst oldVNode = m('div', { id: 'app' }, ['Hello World']);\nconst newVNode = m('div', { id: 'app' }, ['Goodbye World']);\nconst el = createElement(oldVNode);\n// <div id=\"app\">Hello World</div>\n\npatch(el, oldVNode, newVNode);\n// el will become: <div id=\"app\">Goodbye World</div>\nNotes:\nThe old virtual node must always model the DOM element until after it is patched.\nGenerally speaking, applications aren't directly written with these methods, rather they should be abstracted out into components and JSX for simplicity.\nThis is not the same as Million's implementation, rather it is a demonstration to better allow you to understand how the virtual DOM works.\n\n","so-whats-unique-about-million-then#So... What's unique about Million then?":"Million provides many major improvements: granular patching, fewer iterative passes, fast text interpolation, keyed virtual nodes, compiler flags, deltas, batching, and scheduling.\nGranular patching: Instead of just replacing the entire element when there is a difference in props or children, only the necessary props are changed.\nFewer iterative passes: Million attempts to reduce the amount of passes during diffing, allowing for better time and space complexity.\nFast text interpolation: Instead of replacing text nodes with DOM methods, Million uses compiler flags to set the textContent of elements to boost performance.\nKeyed virtual elements: This allows for the patching algorithm to skip nodes if the new virtual element key is the same as the old one, minimizing the amount of unnecessary work.\nCompiler Flags: This allows for the patching algorithm to skip condition branches, meaning less work is done.\nDeltas: Microactions can be preprogrammed to skip diffing children all together, resulting in a better time complexity and while being easily leveraged by a compiler.\nBatching & Scheduling: Batching together DOM manipulations is baked in by default, and task scheduling is composable for your own uses.\n\n"}},"/benchmarks":{"title":"Benchmarks","data":{"":"\n\n"}}}
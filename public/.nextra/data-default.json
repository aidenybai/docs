{"/":{"title":"Home","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, render } from 'million';\n\nlet seconds = 0;\n\nsetInterval(() => {\n  render(document.body, m('p', undefined, [`Time elapsed: ${seconds}`]));\n  seconds++;\n}, 1000);\n\n\nrender() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the parent DOM reference, and the second one is a Virtual DOM to render.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/render/render":{"title":"render()","data":{"":"Syntax: render(parentElement, vnode)\nExample: render(document.body, m('div'), m('div', undefined, ['Hello World']))The render function is a combonation of the patch() and createElement() functions. It takes a parent element and a vnode and returns a DOM node, and renders the vnode into the DOM.\nIf you're seeking more fine grained modification and customization, check out\nthe patch() function.\nHere's an example Counter app using render():\nimport { m, render } from 'million';\n\nlet seconds = 0;\n\nsetInterval(() => {\n  render(document.body, m('p', undefined, [`Time elapsed: ${seconds}`]));\n  seconds++;\n}, 1000);\n\n\nrender() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the parent DOM reference, and the second one is a Virtual DOM to render.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/render/createElement":{"title":"createElement()","data":{"":"Syntax: createElement(vnode, attachField = true)\nExample: createElement(m('div'))The createElement function converts a VNode into a HTMLElement or Text. It accepts a VNode (VElement or string). This is generally used to initialize an root element to use as a reference during patching.\nimport { m, createElement, Flags } from 'million';\n\nconst vnode = m(\n  'div',\n  { id: 'app' },\n  ['Hello World'],\n  Flags.ONLY_TEXT_CHILDREN,\n);\nconst el = createElement(vnode);\n\ndocument.body.appendChild(el);\n\n<div id=\"app\">Hello World</div>\n","old_vnode_field-property#OLD_VNODE_FIELD property":"The OLD_VNODE_FIELD property is a global export on the Million namesplace, as is automatically attached to the new HTMLElement for reference during the patching process. You can disable this by setting the attachField parameter to false, if you are able to manage the old VNode state yourself."}},"/docs/api/render/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVNode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","commit--effects#Commit & effects":"Sometimes, we want to do apply our own functionality across the entire VNode tree, yet we want to keep the API usage very simple. There are two areas where you can do this:\nVNode-by-VNode diffing: You can pass a callback into the commit parameter (see patch) syntax to deal with each VNode (excluding special diffing). You can construct a commit callback like this:\npatch(el, newVNode, oldVNode, [], (callback, data) => callback());\nYou can now access the callback, which you execute, and the data to get the context of the execution.\nOperation-by-Operation patching: Once diffing is completed, you can deal with effects, or DOM operations. Normally, effects are batched all at once, but if you want to modify this, you can check out custom patch functions. If you want to add your own custom effects, you can pass callbacks into the effects parameter like this:\npatch(el, newVNode, oldVNode, [() => console.log('Hello World!')]);\n\n\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport { m, useNode, useChildren, useProps, createElement } from 'million';\n\nconst diff = useNode([useChildren(), useProps()]);\n\nconst customPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\ncustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an implementation of a rudimentary virtual DOM with reference-based diffing of an existing el.\nimport { createElement } from 'million';\n\nconst useNodeReplace =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n    const data = {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n\n    commit(() => {\n      if (!newVNode) {\n        effects.push(() => el.remove());\n      } else if (oldVNode !== newVNode) {\n        effects.push(() => el.replaceWith(createElement(newVNode)));\n      }\n    }, data);\n\n    return data;\n  };\n"}}}
{"/":{"title":"Home","data":{"":"\n\n"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your project directory, run the following command:\nnpm install million\nOr with yarn:\nyarn add million\n","quick-start#Quick Start":"For a normal JavaScript project, you'll first need to import Million's basic functions:\nimport { m, createElement, patch } from 'million';\n\nIf you want to use a templating language like JSX,\nread more here about using JSX\nwith Million\nThen, you can start building your app (e.g. Counter app):\nimport { m, createElement, patch } from 'million';\n\nconst view = (seconds) => m('p', undefined, [`Time elapsed: ${seconds}`]);\n\nconst el = createElement(view(0));\n\nlet seconds = 0;\n\nsetInterval(() => {\n  patch(el, view(seconds));\n  seconds++;\n}, 1000);\n\ndocument.body.appendChild(el);\n\n\npatch() function has a standard interface that is used in many Virtual DOM libraries. First argument is a DOM node that will be used as the live DOM reference, and the second one is a Virtual DOM to render.createElement() function converts a \"Virtual DOM\" node into a real DOM node.m() function will instantiate a \"Virtual DOM\" node for an element."}},"/docs/api/render/patch":{"title":"patch()","data":{"":"Syntax: patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())\nExample: patch(el, m('div'), m('div', undefined, ['Hello World']))The patch function updates the DOM content by determing pinpoint changes through diffing a new VNode with an old VNode. It accepts an HTMLElement or Text, a new VNode, and an optional previous VNode. It also returns the resulting HTMLElement or Text.You can leverage Flags and Deltas to improve the performance of patch calls by reducing the need to diff children by improving time complexity.\nimport { m, patch, createElement } from 'million';\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\npatch(el, vnode1);\n// document.body.innerHTML = '' -> '<div id=\"app\">Hello World</div>'\n\nconst vnode2 = m('div', { id: 'app' }, ['Goodbye World']);\n\npatch(el, vnode2);\n// document.body.innerHTML = '<div id=\"app\">Hello World</div>' -> '<div id=\"app\">Goodbye World</div>'\n","commit--effects#Commit & effects":"Sometimes, we want to do apply our own functionality across the entire VNode tree, yet we want to keep the API usage very simple. There are two areas where you can do this:\nVNode-by-VNode diffing: You can pass a callback into the commit parameter (see patch) syntax to deal with each VNode (excluding special diffing). You can construct a commit callback like this:\npatch(el, newVNode, oldVNode, [], (callback, data) => callback());\nYou can now access the callback, which you execute, and the data to get the context of the execution.\nOperation-by-Operation patching: Once diffing is completed, you can deal with effects, or DOM operations. Normally, effects are batched all at once, but if you want to modify this, you can check out custom patch functions. If you want to add your own custom effects, you can pass callbacks into the effects parameter like this:\npatch(el, newVNode, oldVNode, [() => console.log('Hello World!')]);\n\n\n","custom-patch-functions#Custom patch functions":"You can use drivers to create your own custom patch functions. The useNode() driver accepts an array of drivers, which runs after the sweeping modifications of an element is patched and more pinpoint modifications may be necessary.Driver Syntax: useNode([useChildren(), useProps(), useDriver([useAnotherDriver()])])\nDriver Signature: (el, newVNode, oldVNode, effects, commit, driver) => { ...; return { el, newVNode, oldVNode, effects, commit, driver } }If you use a IDE like VSCode, you can look into the implementations of how to create a Driver and create your own drivers.\nimport {\n  m,\n  useNode,\n  useChildren,\n  useProps,\n  createElement,\n  flush,\n} from 'million';\n\nconst myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {\n  const diff = useNode([useChildren(), useProps()]);\n  const data = diff(el, newVNode, oldVNode, effects, commit);\n  for (let i = 0; i < effects.length; i++) {\n    effects[i]();\n  }\n  return data.el;\n};\n\nconst vnode0 = m('div');\nconst el = createElement(vnode0);\n\ndocument.body.appendChild(el);\nconst vnode1 = m('div', { id: 'app' }, ['Hello World']);\n\nmyCustomPatch(el, vnode1);\n","writing-your-own-drivers#Writing your own drivers":"Below is an example template for your own custom driver:\nconst useDriver =\n  (drivers = []) =>\n  (el, newVNode, oldVNode, effects = [], commit, driver) => {\n    /**\n     * `drivers` can add another optional layer of composibility, you can run the drivers\n     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated\n     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.\n     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!\n     */\n\n    return {\n      el,\n      newVNode,\n      oldVNode,\n      effects,\n      commit,\n      driver,\n    };\n  };\n"}}}
---
title: m
---

import Callout from 'nextra-theme-docs/callout';

# `m`

**语法：** `m(tag, props?, children?, flag?, delta?)`\
**示例：** `m('div', { id: 'app' }, ['Hello World'])`

建议您使用 `m` 创建 VNode。它接受一个字符串形式的标签、一个可选的 props 对象、一个可选的子数组和一个可选的标志。

```js
import { m } from 'million';

const vnode = m('div', { id: 'app' }, ['Hello World']);
```

```js
{
  tag: 'div',
  props: {
    id: 'app'
  },
  children: ['Hello World'],
}
```

## `className` 和 `style` 道具

`className` 和 `style` 属性需要使用 `className` 和 `style` 函数进行预处理，以将对象转换为字符串。类对象语法允许您根据布尔值切换类。样式对象语法允许您以干净的格式设置样式。

```js
import { m, className, style } from 'million';

const vnode = m(
  'div',
  {
    className: className({ class1: true, class2: false, class3: 1 + 1 === 2 }),
    style: style({ color: 'black', 'font-weight': 'bold' }),
  },
  ['Hello World'],
);
```

```js {4,5}
{
  tag: 'div',
  props: {
    className: 'class1 class3',
    style: 'color:black;font-weight:bold'
  },
  children: ['Hello World'],
}
```

## Kebab 道具助手

通常，`className` 和 `style` props 的值是 kebab-case 中的对象。但是，如果您想对这些 props 的键使用 camelCase，您可以使用 `kebab` 函数将键从 camelCase 转换为 kebab-case。

```js
import { m, style, kebab } from 'million';

const vnode = style(kebab({ color: 'black', fontWeight: 'bold' }));
```

```js {4}
{
  tag: 'div',
  props: {
    style: 'color:black;font-weight:bold'
  },
  children: ['Hello World'],
}
```

## SVG 支持

使用 `svg` 函数处理 SVG 以将 `ns` 道具添加到元素和该元素的所有子元素。

```js
import { m, svg } from 'million';

const vnode = svg(m('svg'));
```

```js {4}
{
  tag: 'svg',
  props: {
    ns: 'http://www.w3.org/2000/svg'
  },
}
```

## 按键优化

大多数情况下，diffing 和 patching 过程已经足够快了，但是在处理大量的 child 时，最好通过 key 提供运行时提示。您可以在道具下附加一个“钥匙”。修补后，如果更改了 `key`，它只会区分道具和孩子。要使用键进行更高级的运行时差异，请查看 [`Flags.ONLY_KEYED_CHILDREN`](#flags)。

```js
import { m } from 'million';

const vnode = m('div', { key: 'foo' }, ['Hello World']);
```

```js {5}
{
  tag: 'div',
  props: {},
  children: ['Hello World'],
  key: 'foo',
}
```

## 标志

标志允许 `patch` 函数优化条件分支。它们是可选的，但**强烈推荐**，因为它们使时间复杂度更加高效，并且可以在编译时预先计算。

<Callout emoji="ℹ️">
  如果在 `patch` 期间生成的 vnode 作为前一个 vnode 提供，则标志将被忽略 称呼。
</Callout>

- **`Flags.IGNORE_NODE`**\
  当您确定不需要对节点执行任何修补时，应使用此标志。这对于优化交互区域内的静态区域很有用。

  ```js
  import { m, Flags } from 'million';

  const vnode = m('div', undefined, ['Please ignore me'], Flags.IGNORE_NODE);
  ```

  ```js {4}
  {
    tag: 'div',
    children: ['Please ignore me'],
    flag: /* Flags.IGNORE_NODE */,
  }
  ```

- **`Flags.REPLACE_NODE`**\
  如果您需要添加组功能，使用此标志可以让您完全跳过差异并硬替换 vnode。

  ```js
  import { m, Flags } from 'million';

  const vnode = m('div', undefined, ['Please hard replace me'], Flags.REPLACE_NODE);
  ```

  ```js {4}
  {
    tag: 'div',
    children: ['Please hard replace me'],
    flag: /* Flags.REPLACE_NODE */,
  }
  ```

- **`Flags.NO_CHILDREN`**\
  如果您的元素没有子元素，则可以设置此标志以完全跳过子元素的差异。

  ```js
  import { m, Flags } from 'million';

  const vnode = m('div', undefined, [], Flags.NO_CHILDREN);
  ```

  ```js {4}
  {
    tag: 'div',
    children: [],
    flag: /* Flags.NO_CHILDREN */,
  }
  ```

- **`Flags.ONLY_TEXT_CHILDREN`**\
  如果你的元素只有文本子元素，你可以设置这个标志来跳过子元素的差异，并且只改变 HTMLElement 的 `textContent` 属性。

  ```js
  import { m, Flags } from 'million';

  const vnode = m('div', undefined, ['Hello ', 'World!'], Flags.ONLY_TEXT_CHILDREN);
  ```

  ```js {4}
  {
    tag: 'div',
    children: ['Hello ', 'World!'],
    flag: /* Flags.ONLY_TEXT_CHILDREN */,
  }
  ```

- **`Flags.ONLY_KEYED_CHILDREN`**\
  如果您的元素只有带有键的 VElement 子元素，则可以将此标志设置为默认值以启用特殊差异。这允许更高性能的运行时差异，因为它可以利用键映射进行比较以进行更多精确修改。

  例如，在没有键控差异的情况下，每个节点都是线性差异的，有时会导致不必要的修改。如下所示，我们在 `newVNodeChildren` 的开头插入了一个 `X` 子节点，但所有节点都被修改了，因为前 3 个节点经过了差异和更新，最后一个节点被追加了。如果只在开头插入“X”，这可能会更有效。

  ```js {7,8,9,10}
  oldVNodeChildren:
    A,
    B,
    C,

  newVNodeChildren:
    X,
    A,
    B,
    C,
  ```

  但是，通过键控差异，我们可以看到更高性能的结果。如您所见，只有“X”被修改并在开始时插入，其他节点在比较期间被忽略。

  ```js {7}
  oldVNodeChildren:
    A,
    B,
    C,

  newVNodeChildren:
    X,
    A,
    B,
    C,
  ```

  那么，如何启用此功能？一般来说，如果你的价值观中有独特的内容，你应该这样做。永远不要将数组中项目的索引或非唯一键提供给 VNode。

  ```js
  import { m, Flags } from 'million';

  const list = ['foo', 'bar', 'baz'];

  const vnode = m(
    'div',
    undefined,
    list.map((item) => m('p', { key: item }, [item])),
    Flags.ONLY_KEYED_CHILDREN,
  );
  ```

  ```js {8}
  {
    tag: 'div',
    children: [
      m('p', { key: 'foo' }, ['foo']),
      m('p', { key: 'bar' }, ['bar']),
      m('p', { key: 'foo' }, ['baz']),
    ],
    flag: /* Flags.ONLY_KEYED_CHILDREN */,
  }
  ```

- **`Flags.ANY_CHILDREN`**\
  如果您的元素有混合或只有 VElement 子元素，您可以将此标志设置为默认为正常差异。通常，您不需要显式设置此标志，因为它是默认行为。

  ```js
  import { m, Flags } from 'million';

  const vnode = m(
    'div',
    undefined,
    ['Here is my button: ', m('button', undefined, ['Hi!'])],
    Flags.ANY_CHILDREN,
  );
  ```

  ```js 4"
  {
    tag: 'div',
    children: ['Here is my button: ', { tag: 'button', children: ['Hi'] }],
    flag: /* Flags.ANY_CHILDREN */,
  }
  ```

## Deltas

增量是编译时通过提供一组预定义操作来优化运行时操作的一种方式。这对于您在高间隔、低负载情况下执行一致、可预测的操作的情况很有用。

增量操作共有三种类型：`Delta.INSERT`、`Delta.UPDATE` 和`Delta.DELETE`。您可以提供指定的索引来选择要插入、更新或删除的 vnode 子节点的位置。

- `Delta.INSERT` 用于在选定索引处添加子级。\
  **语法：** `Delta.INSERT(index)`\
  **示例：** `IDelta.NSERT(0)`

- `Delta.UPDATE` 用于替换选定索引处的子项。\
  **语法：** `Delta.UPDATE(index)`\
  **示例：** `Delta.UPDATE(0)`

- `Delta.DELETE` 用于删除选定索引处的子项。\
  **语法：** `Delta.DELETE(index)`\
  **示例：** `Delta.DELETE(0)`

您可以将这些操作加载到增量或数组中。您可以在 `m` 函数中传递它们。

```js
import { m, Delta } from 'million';

const vnode = m('div', undefined, ['Hello World'], undefined, [Delta.INSERT(0), Delta.UPDATE(0)]);
```

```js {5,6}
{
  tag: 'div',
  children: ['Hello World'],
  delta: [
    [0 /* DeltaTypes.INSERT */, 0],
    [1 /* DeltaTypes.UPDATE */, 0],
  ]
}
```

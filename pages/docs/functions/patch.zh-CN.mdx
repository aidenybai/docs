---
title: patch
---

# `patch`

**语法：** `patch(element, newVnode, prevVNode?, effects = [], commit = (callback) => callback())`\
**示例：** `patch(el, m('div'), m('div', undefined, ['Hello World']))`

`patch` 函数通过区分新 VNode 和旧 VNode 来确定精确更改来更新 DOM 内容。它接受一个 HTMLElement 或 Text、一个新的 VNode 和一个可选的先前 VNode。它还返回生成的 HTMLElement 或 Text。

您可以利用 [Flags](/functions/m#flags) 和 [Deltas](/functions/m#deltas) 通过提高时间复杂度来减少区分子项的需要来提高补丁调用的性能。

```js
import { m, patch, createElement } from 'million';

const vnode0 = m('div');
const el = createElement(vnode0);

document.body.appendChild(el);
const vnode1 = m('div', { id: 'app' }, ['Hello World']);

patch(el, vnode1);
// document.body.innerHTML = '' -> '<div id="app">Hello World</div>'

const vnode2 = m('div', { id: 'app' }, ['Goodbye World']);

patch(el, vnode2);
// document.body.innerHTML = '<div id="app">Hello World</div>' -> '<div id="app">Goodbye World</div>'
```

## 自定义补丁函数

您可以使用驱动程序来创建自己的自定义补丁功能。 `node()` 驱动程序接受一个驱动程序数组，这些驱动程序在对元素的全面修改进行修补后运行，并且可能需要进行更多精确修改。

**驱动语法：** `node([children(), props(), yourOwnDriver([anotherDriver()])])`\
**`Driver` 签名：** `(el, newVNode, oldVNode, effects, commit, driver) => { ...;返回{ el，newVNode，oldVNode，效果，提交，驱动程序}}`

如果您使用像 [VSCode](https://code.visualstudio.com/) 这样的 IDE，您可以查看如何创建“驱动程序”并创建自己的驱动程序的实现。

```js
import { m, node, children, props, createElement, flush } from 'million';

const myCustomPatch = (el, newVNode, oldVNode, effects = [], commit) => {
  const diff = node([children(), props()]);
  const data = diff(el, newVNode, oldVNode, effects, commit);
  for (let i = 0; i < effects.length; i++) {
    effects[i]();
  }
  return data.el;
};

const vnode0 = m('div');
const el = createElement(vnode0);

document.body.appendChild(el);
const vnode1 = m('div', { id: 'app' }, ['Hello World']);

myCustomPatch(el, vnode1);
```

## Writing your own drivers

Below is an example template for your own custom driver:

```js
const customDriver =
  (drivers = []) =>
  (el, newVNode, oldVNode, effects = [], commit, driver) => {
    /**
     * `drivers` can add another optional layer of composibility, you can run the drivers
     * by passing the same `drivers[i](el, newVNode, oldVNode, effects, commit, driver)`, or a manipulated
     * version downstream `drivers[i](el.childNodes[j], newVNode.children[j], undefined, effects, commit, driver)`.
     * The great thing about sub-drivers is you can run them anywhere you want inside the driver!
     */

    return {
      el,
      newVNode,
      oldVNode,
      effects,
      commit,
      driver,
    };
  };
```
